% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loglik_fun.R
\name{fit_scalegev}
\alias{fit_scalegev}
\title{Fit a scale-GEV-model to data}
\usage{
fit_scalegev(
  data,
  temp.cov,
  method = "BFGS",
  maxiter = 300,
  hessian = TRUE,
  printStartVals = FALSE,
  start_val = NULL
)
}
\arguments{
\item{data}{Either a numeric vector of observations, or a matrix containing
observations from several stations/regions in its columns. In the latter case,
the prameters of the scale-GEV-model are assumed to be the same across columns,
such that only one set of parameters is computed.}

\item{temp.cov}{Values of the temporal covariate of the scale-GEV-model.
Must be of same record length as thr observations.}

\item{method}{Method passed to \code{\link[stats]{optim}}.}

\item{maxiter}{Maximum number of iterations during maximisation (also passed to
\code{\link[stats]{optim}}).}

\item{hessian}{logical; whether to return the numerically differentiated Hessian matrix.}

\item{printStartVals}{logical; whether to print start values of optimisation.}

\item{start_val}{Optional: vector containing start values for the ML optimisation.}
}
\value{
A list containing the components
\itemize{
\item mle: Estimated parameter values
\item nll : Value of the negative log-likelihood evaluated at the optimised parameters
\item conv : convergence code from \code{\link[stats]{optim}} (0 means successful convergence)
\item hessian: The numerically differentiated Hessian matrix (when hessian was TRUE)
}
}
\description{
Fit a scale-GEV-model to data
}
\examples{
# generate univariate data
xx <- exp((1:100)/100)*evd::rgev(100)
fit_scalegev(data = xx, temp.cov = (1:100)/100, printStartVals = TRUE)

# generate 3 dimensional data:
xx <- matrix(rep(exp((1:100)/100), 3)*evd::rgev(300), ncol = 3)
fit_scalegev(data = xx, temp.cov = (1:100)/100, printStartVals = TRUE)
}
