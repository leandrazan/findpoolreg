% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_cov.R
\name{compute_sigmajk}
\alias{compute_sigmajk}
\title{Estimate covariance of ML estimation applied to two stations}
\usage{
compute_sigmajk(par.j, par.k, Gammajk, temp.cov, Jinv.j, Jinv.k)
}
\arguments{
\item{par.j}{Estimated parameter vector for station j}

\item{par.k}{Estimated parameter vector for station k}

\item{Gammajk}{Estimated covariance matrix of score function applied to data standardised to GEV margins,
as computed by \code{\link[findpoolreg]{estimate_gammas}}}

\item{temp.cov}{Values of temporal covariate}

\item{Jinv.j}{Inverse of hessian returned by calling \code{\link[findpoolreg]{fit_scalegev}} on data from station j}

\item{Jinv.k}{Inverse of hessian returned by calling \code{\link[findpoolreg]{fit_scalegev}} on data from station k}
}
\value{
A 4x4 matrix containing an estimate of
\eqn{ Cov( \theta_j, \theta_k)}.
}
\description{
Estimate covariance of ML estimation applied to two stations
}
\examples{

# generate data
cvrt <- (1:100)/100
d <- 16
coords <- matrix(20*abs(stats::rnorm(d*2)), ncol = 2)
x <- generateData(seed = 1, n = 100, temp.cov = cvrt, d= d, locations = coords)

# compute ML estimate at each station
mle1 <- fit_scalegev(x[, 1], temp.cov =cvrt)
mle3 <- fit_scalegev(x[, 3], temp.cov =cvrt)


# compute covariance between ML estimate of station 1 and ML estimate of station 3
Gams <-  estimate_gammas(x[, c(1,3)], parmat = cbind(mle1$mle, mle3$mle),
                         temp.cov =cvrt, rel_par = FALSE)
compute_sigmajk(mle1$mle, mle3$mle, Gams[ 1:3, 4:6], cvrt,
                solve(mle1$hessian), solve(mle3$hessian))

}
